---
title: Access Chez Scheme documentation from the REPL
author: Travis Hinkelman
date: '2020-01-01'
slug: access-chez-scheme-documentation-from-repl
categories:
  - ChezScheme
  - R
  - chez-docs
tags:
  - rvest
  - tsv
  - association-list
  - system
draft: false
---



<p>In the process of learning Chez Scheme, I’ve missed R’s ability to quickly pull up documentation from the console via <a href="https://www.r-project.org/help.html"><code>help</code> or <code>?</code></a>. I’ve toyed with the idea of trying to format the contents of the <a href="https://cisco.github.io/ChezScheme/csug9.5/">Chez Scheme User’s Guide</a> for display in the REPL (similar to <a href="https://clojuredocs.org/clojure.repl/doc">Clojure Docs</a>). But that is probably too big of a task for me at this point. It recently occurred to me, though, that I can write a simple library, <a href="https://github.com/hinkelman/chez-docs"><code>chez-docs</code></a>, with only one procedure, <code>doc</code>, that will make it a bit easier to access the Chez Scheme User’s Guide.</p>
<p>My typical entry point to learning about Chez Scheme is the <a href="https://cisco.github.io/ChezScheme/csug9.5/summary.html">Summary of Forms</a> page of the Chez Scheme User’s Guide. The simple idea behind <code>chez-docs</code> is to scrape the data from the Summary of Forms page and write a procedure that opens links to the documentation from the REPL.</p>
<div id="web-scraping-with-r" class="section level3">
<h3>Web Scraping with R</h3>
<p>I used the <a href="http://rvest.tidyverse.org"><code>rvest</code> package</a> for R to scrape the data from the Summary of Forms page. First, I downloaded the page and opened it in a text editor to see how the table was structured. Then, I extracted the URLs by drilling down into the nodes of the HTML document and retrieving the contents of the <code>href</code> attribute.</p>
<pre><code>library(tidyverse)
library(rvest)

chez_url = &quot;https://cisco.github.io/ChezScheme/csug9.5/summary.html&quot;

chez_links &lt;- read_html(chez_url) %&gt;% 
  html_nodes(&quot;table&quot;) %&gt;% 
  html_nodes(&quot;tr&quot;) %&gt;% 
  html_nodes(&quot;a&quot;) %&gt;% 
  html_attr(&quot;href&quot;)</code></pre>
<p>Next, I retrieved the text contents of the HTML table. <code>html_table</code> returns a list with all of the tables on the page as data frames. In this case, there is only one table in the list.</p>
<pre><code>chez_table_list &lt;- read_html(chez_url) %&gt;% 
  html_nodes(&quot;table&quot;) %&gt;% 
  html_table()</code></pre>
</div>
<div id="data-preparation-with-r" class="section level3">
<h3>Data Preparation with R</h3>
<p>The Summary of Forms page links to two sources: <a href="https://www.scheme.com/tspl4/">The Scheme Programming Language (TSPL)</a> and the <a href="https://cisco.github.io/ChezScheme/csug9.5/">Chez Scheme User’s Guide (CSUG)</a>. A <code>t</code> in the page number indicates TSPL as the source. The extracted URLs linking to those sources required a little cleanup.</p>
<p>I’m using <code>Key</code> to mean the first ‘word’ in the <code>Form</code> column. In many cases, that ‘word’ is just a symbol, e.g., <code>&gt;</code>, <code>+</code>, <code>*</code>, etc.</p>
<pre><code>chez_table &lt;- chez_table_list[[1]] %&gt;% 
  filter(Form != &quot;&quot;) %&gt;%          # drop empty first row
  mutate(URL = chez_links,
         # clean up extracted links to TSPL
         URL = gsub(pattern = &quot;http://scheme.com/tspl4/./&quot;,
                    replacement = &quot;https://scheme.com/tspl4/&quot;,
                    URL),
         # convert relative to absolute links for CSUG
         URL = gsub(pattern = &quot;^\\.&quot;, 
                    replacement = &quot;https://cisco.github.io/ChezScheme/csug9.5&quot;, 
                    x = URL),
         Key = sapply(strsplit(Form, &quot;\\s&quot;), &quot;[[&quot;, 1),
         Key = gsub(&quot;\\(|\\)&quot;, &quot;&quot;, Key),
         Source = ifelse(substr(Page, 1, 1) == &quot;t&quot;, &quot;TSPL&quot;, &quot;CSUG&quot;)) %&gt;% 
  select(Key, Form, Source, URL) </code></pre>
<p>The problem here is that <code>Key</code> is not unique because the same key can be associated with more than one form and/or more than one source. I decided that the simplest solution was to separate the keys by source and combine the forms for each key that shared the same URL. I used nested <code>for</code> loops to tear down the data frame and build it back up.</p>
<pre><code>source_list &lt;- list()
excluded_list &lt;- list()
for (j in c(&quot;CSUG&quot;, &quot;TSPL&quot;)){
  ct_source &lt;- filter(chez_table, Source == j)
  key_list &lt;- list()
  excluded &lt;- c()
  for (i in unique(ct_source$Key)){
    ctsk &lt;- filter(ct_source, Key == i)
    if (nrow(ctsk) == 1){
      key_list[[i]] &lt;- ctsk
    } else {
      if (nrow(unique(select(ctsk, Key, Source, URL))) == 1){
        key_list[[i]] &lt;- tibble(Key = i,
                                Form = paste(unique(ctsk$Form), collapse = &quot;~&quot;),
                                Source = j,
                                URL = ctsk$URL[1])
      } else {
        excluded &lt;- c(excluded, i)
      }
    }
  }
  excluded_list[[j]] &lt;- excluded
  source_list[[j]] &lt;- bind_rows(key_list)
}
out &lt;- bind_rows(source_list)</code></pre>
<p>I decided that it would look nice to separate the forms with newlines for display in Chez, but writing and reading files with newlines as separators within a column creates a mess. Instead, I chose <code>~</code> as the separator in the <code>Form</code> column because it is not a character that appears in any of the forms, which makes it easier to replace with <code>\n</code> on the Chez side.</p>
<p>I kept track of which keys were excluded to decide if I needed to take additional processing steps. <code>alias</code> and <code>let</code> were the only keys that were excluded because the two forms are associated with two different links. No additional processing was done to include <code>alias</code> and <code>let</code>.</p>
<p>The last step in R was to write the processed table to file. Because some of the forms contain commas, e.g., <code>#,template</code>, I wrote the table as a TSV file. I split the table into two files because it made the processing simpler in Chez.</p>
<pre><code>for (j in c(&quot;CSUG&quot;, &quot;TSPL&quot;)){
  out %&gt;% 
    filter(Source == j) %&gt;% 
    select(-Source) %&gt;% 
    write_tsv(paste0(j, &quot;.tsv&quot;))
}</code></pre>
</div>
<div id="data-preparation-with-chez-scheme" class="section level3">
<h3>Data Preparation with Chez Scheme</h3>
<p>First, I needed to make a small modification to my <a href="https://github.com/hinkelman/chez-stats/blob/dev/csv.ss"><code>csv</code> library</a> to read TSV files. Then, I read each TSV file, dropped the header row, and converted each row into an association list where the first element of the row is the key and values are represented by a list of the other two values in the row (i.e., forms and URLs). The two association lists were then combined to create a nested association list, which was written to file.</p>
<pre><code>(import (chez-stats chez-stats))

(define csug (cdr (read-tsv &quot;R/CSUG.tsv&quot;)))
(define tspl (cdr (read-tsv &quot;R/TSPL.tsv&quot;)))

(define csug-alist (map (lambda (x) (list (car x) (cdr x))) csug))
(define tspl-alist (map (lambda (x) (list (car x) (cdr x))) tspl))

(define data (list (list &quot;CSUG&quot; csug-alist)
                   (list &quot;TSPL&quot; tspl-alist)))

(with-output-to-file &quot;data.scm&quot; (lambda () (write data)))</code></pre>
</div>
<div id="reading-data-in-chez-scheme-library" class="section level3">
<h3>Reading Data in Chez Scheme Library</h3>
<p>To read the data when <code>chez-docs</code> is loaded, we need to identify the path where the data is located. For <code>(import (chez-docs docs))</code> to work, the user needs to have installed <code>chez-docs</code> in a directory found by <code>(library-directories)</code> (see this <a href="/post/getting-started-with-chez-scheme-and-emacs/">blog post</a> for more information on library directories). Thus, we can loop through the list of library directories to find the file location and read the data.</p>
<pre><code>(define data-paths
  (map (lambda (x) (string-append x &quot;/chez-docs/data.scm&quot;))
       (map car (library-directories))))

(define data
  (let ([tmp &#39;()])
    (for-each
     (lambda (path)
       (when (file-exists? path)
         (set! tmp (with-input-from-file path read))))
     data-paths)
    tmp))</code></pre>
</div>
<div id="launching-documentation" class="section level3">
<h3>Launching Documentation</h3>
<p>The main procedure in <code>chez-docs</code> is <code>doc</code>, which uses <code>case-lambda</code> to handle optional arguments with default values.</p>
<pre><code>(define doc
  (case-lambda
    [(proc) (doc-helper proc &quot;both&quot; #t)]
    [(proc source) (doc-helper proc source #t)]
    [(proc source launch?) (doc-helper proc source launch?)]))</code></pre>
<p><code>data-lookup</code> checks that the strings passed as arguments are valid and returns a list of the association lists for <code>proc</code> from the <code>data</code> object created above.</p>
<pre><code>(define (data-lookup proc source)
  (cond [(or (string=? source &quot;CSUG&quot;) (string=? source &quot;TSPL&quot;))
         (list (dl-helper proc source))]
        [(string=? source &quot;both&quot;)
         (let ([csug (dl-helper proc &quot;CSUG&quot;)]
               [tspl (dl-helper proc &quot;TSPL&quot;)])
           (if (or csug tspl)
               (list csug tspl)
               (assertion-violation &quot;(doc proc)&quot; &quot;procedure not found&quot;)))]
        [else
         (assertion-violation &quot;(doc proc source)&quot; &quot;source not one of CSUG, TSPL, both&quot;)]))
         
;; data is imported above
(define (dl-helper proc source)
  (assoc proc (cadr (assoc source data)))) </code></pre>
<p>When using <code>data-lookup</code> on <code>&lt;</code>, we see that there is an entry for <code>&lt;</code> in both CSUG and TPSL as there is an association list returned for both elements of the list.</p>
<pre><code>&gt; (data-lookup &quot;&lt;&quot; &quot;both&quot;)
((&quot;&lt;&quot; (&quot;(&lt; real1 real2 real3 ...)&quot;
        &quot;https://cisco.github.io/ChezScheme/csug9.5/numeric.html#./numeric:s67&quot;))
  (&quot;&lt;&quot; (&quot;(&lt; real1 real2 real3 ...)&quot;
         &quot;https://scheme.com/tspl4/objects.html#./objects:s88&quot;)))</code></pre>
<p>If <code>proc</code> is only found in one source, and both are requested, then one element of the returned list will be <code>#f</code>.</p>
<pre><code>&gt; (data-lookup &quot;map&quot; &quot;both&quot;)
(#f (&quot;map&quot;
      (&quot;(map procedure list1 list2 ...)&quot;
        &quot;https://scheme.com/tspl4/control.html#./control:s30&quot;)))</code></pre>
<p><code>display-launch</code> takes an association list, <code>data-selected</code>, returned by <code>data-lookup</code>, displays the form(s), and optionally opens a link to the relevant section of the documentation in your default browser. When <code>launch?</code> is <code>#t</code>, <code>display-launch</code> makes a system call to <code>open</code> (macOS), <code>xdg-open</code> (Linux), or <code>start</code> (Windows) and requires an internet connection.</p>
<pre><code>(define (display-launch data-selected launch?)
  (when data-selected
    (display (replace-tilde (string-append (caadr data-selected) &quot;\n&quot;)))
    (when launch?
      (system (string-append open-string (cadadr data-selected))))))</code></pre>
<p><code>(machine-type)</code> is used to determine the system-specific string, <code>open-string</code>, for use in the system call.</p>
<pre><code>(define open-string
  (case (machine-type)
    [(i3nt ti3nt a6nt ta6nt) &quot;start &quot;]     ; windows
    [(i3osx ti3osx a6osx ta6osx) &quot;open &quot;]  ; mac
    [else &quot;xdg-open &quot;]))                   ; linux</code></pre>
<p>When <code>launch?</code> is <code>#f</code>, <code>display-launch</code> simply displays the form(s) for the specified <code>proc</code>, which is helpful if you can’t remember the order of arguments for a procedure.</p>
<pre><code>&gt; (display-launch (car (data-lookup &quot;append&quot; &quot;TSPL&quot;)) #f)
(append)
(append list ... obj)</code></pre>
<p>For multi-line display of forms, the <code>~</code> added in R to separate forms is replaced with <code>\n</code> using <code>replace-tilde</code>.</p>
<pre><code>(define (replace-tilde str)
  (let* ([in (open-input-string str)]
         [str-list (string-&gt;list str)])
    (if (not (member #\~ str-list))
        str  ;; return string unchanged b/c no tilde
        (let loop ([c (read-char in)]
                   [result &quot;&quot;])
          (cond [(eof-object? c)
                 result]
                [(char=? c #\~)
                 (loop (read-char in) (string-append result &quot;\n&quot;))]
                [else
                 (loop (read-char in) (string-append result (string c)))])))))</code></pre>
<p>The last piece is <code>doc-helper</code>, which loops through the output of <code>data-lookup</code> and passes it to <code>display-launch</code>.</p>
<pre><code>(define (doc-helper proc source launch?)
  (define (loop ls)
    (cond [(null? ls) (void)]
          [else
           (display-launch (car ls) launch?)
           (loop (cdr ls))]))
  (loop (data-lookup proc source)))</code></pre>
<p>The downside of this approach is that if a <code>proc</code> is found in both sources with the same form, then it will be displayed twice. I decided this behavior isn’t sufficiently annoying to take the extra steps to prevent it from happening.</p>
<pre><code>&gt; (doc &quot;&lt;&quot; &quot;both&quot; #f)
(&lt; real1 real2 real3 ...)
(&lt; real1 real2 real3 ...)</code></pre>
</div>
<div id="conclusions" class="section level3">
<h3>Conclusions</h3>
<p>This was a fun little project. When I first had the idea, I was really excited because I worked out all of the initial code in less than 2 hours. But, when I started to write this blog post, I started to discover all of the little problems that didn’t occur to me initially. Nonetheless, I think that I might have produced something reasonably useful for myself from a modest effort.</p>
</div>
