---
title: A dataframe record type for Chez Scheme
author: Travis Hinkelman
date: '2020-03-27'
slug: dataframe-record-type-for-chez-scheme
categories: ["dataframe", "Chez Scheme"]
tags:
  - dataframe
  - data-structures
  - association-list
draft: false
---



<p>As an exercise in my Chez Scheme learning journey, I have implemented a <a href="https://hinkelman.github.io/dataframe/">dataframe record type</a> and procedures to work with the dataframe record type. Dataframes are column-oriented, tabular data structures useful for data analysis found in several languages including <a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/data.frame.html">R</a>, <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">Python</a>, <a href="https://juliadata.github.io/DataFrames.jl/stable/">Julia</a>, and <a href="https://github.com/rocketlaunchr/dataframe-go">Go</a>. In this post, I will introduce the dataframe record type and basic procedures for working with dataframes. In subsequent posts, I will describe other dataframe procedures, e.g., filter, sort, aggregate, etc.</p>
<p>A key design decision was to opt for an immutable data structure. Thus, dataframes are based on association lists (alists) rather than hashtables. I find it easier to reason about immutable data and thought the performance trade-off was worth it for this excercise. Here are the properties of a dataframe:</p>
<ul>
<li>an alist where each sublist is a column;</li>
<li>the first element of each column is the column name;</li>
<li>the column name must be a symbol;</li>
<li>all column names must be unique;</li>
<li>all columns must have the same length.</li>
</ul>
<div id="dataframe-record-type" class="section level3">
<h3>Dataframe record type</h3>
<p>I won’t profess to have a good understanding of record types. This is what I came up with for dataframes.</p>
<pre><code>(define-record-type dataframe (fields alist names dim)
                    (protocol
                     (lambda (new)
                       (lambda (alist)
                         (let ([proc-string &quot;(make-dataframe alist)&quot;])
                           (check-alist alist proc-string))
                         (new alist
                              (map car alist)
                              (cons (length (cdar alist)) (length alist)))))))</code></pre>
<p>A key component of the record definition is <code>check-alist</code>, which confirms that the alist meets the definition of a dataframe (see bulleted list above). Each dataframe has three fields (i.e., <code>alist</code>, <code>names</code>, and <code>dim</code>), but <code>alist</code> is the only required field. The other two are based on the properties of the <code>alist</code>. <code>define-record-type</code> creates a predicate, <code>dataframe?</code>, constructor procedure, <code>make-dataframe</code>, and accessor procedures for each field: <code>dataframe-alist</code>, <code>dataframe-names</code>, and <code>dataframe-dim</code>.</p>
<pre><code>&gt; (define df (make-dataframe &#39;((a 1 2 3) (b 4 5 6))))

&gt; df
#[#{dataframe cziqfonusl4ihl0gdwa8clop7-3} ((a 1 2 3) (b 4 5 6)) (a b) (3 . 2)]

&gt; (dataframe? df)
#t

&gt; (dataframe? &#39;((a 1 2 3) (b 4 5 6)))
#f

&gt; (dataframe-alist df)  
((a 1 2 3) (b 4 5 6))

&gt; (dataframe-names df)
(a b)

&gt; (dataframe-dim df)
(3 . 2)                  ; (rows . columns)

&gt; (define df (make-dataframe &#39;((&quot;a&quot; 1 2 3) (&quot;b&quot; 4 5 6))))
Exception in (make-dataframe alist): names are not symbols

&gt; (dataframe-display df)
         a         b
         1         4
         2         5
         3         6</code></pre>
</div>
<div id="head-and-tail" class="section level3">
<h3>Head and tail</h3>
<p>In R, I frequently use <code>head</code> to preview the first few rows of a dataframe and, less frequently, use <code>tail</code> to view the last few rows. Chez Scheme provides <code>list-head</code> and <code>list-tail</code> with similar functionality. However, <code>tail</code> in R returns the last <code>n</code> rows of the dataframe whereas <code>list-tail</code> in Chez Scheme returns the rest of the list starting at a given index. My first instinct was to write <code>dataframe-tail</code> to use the R behavior, but eventually decided that <code>dataframe-tail</code> should follow the behavior established by <code>list-tail</code>.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<pre><code>(define (dataframe-head df n)
  (let ([proc-string  &quot;(dataframe-head df n)&quot;])
    (check-dataframe df proc-string)
    (check-integer-positive n &quot;n&quot; proc-string)
    (check-index n (car (dataframe-dim df)) proc-string)
    (make-dataframe (alist-head-tail (dataframe-alist df) n list-head))))

;; dataframe-tail is based on list-tail, which does not work the same as tail in R
(define (dataframe-tail df n)
  (let ([proc-string  &quot;(dataframe-tail df n)&quot;])
    (check-dataframe df proc-string)
    (check-integer-gte-zero n &quot;n&quot; proc-string)
    (check-index (sub1 n) (car (dataframe-dim df)) proc-string)
    (make-dataframe (alist-head-tail (dataframe-alist df) n list-tail))))

(define (alist-head-tail alist n proc)
  (map (lambda (col) (cons (car col) (proc (cdr col) n))) alist))</code></pre>
<p><code>dataframe-head</code> and <code>dataframe-tail</code> illustrate a common pattern in the <code>dataframe</code> library: extracting the alist, breaking the alist into sublists, working on the sublists, and then rebuilding the alist and dataframe. In the case of <code>dataframe-head</code> and <code>dataframe-tail</code>, the core logic is so simple that most of the code involves checking inputs.</p>
</div>
<div id="transpose" class="section level3">
<h3>Transpose</h3>
<p>Dataframes are a column-oriented data structure. However, the more natural pattern when <a href="/posts/reading-writing-csv-files-chez-scheme/">reading and writing CSV files</a> is to use a row-oriented list, which I’m calling a <code>rowtable</code>. <code>dataframe-&gt;rowtable</code> and <code>rowtable-&gt;dataframe</code> allow for switching between row and column orientation.</p>
<pre><code>&gt; (define df (make-dataframe &#39;((a 100 300) (b 4 6) (c 700 900))))

&gt; (dataframe-&gt;rowtable df)
((a b c) (100 4 700) (300 6 900))

&gt; (dataframe-display (rowtable-&gt;dataframe &#39;((a b c) (1 4 7) (2 5 8) (3 6 9)) #t))
         a         b         c
         1         4         7
         2         5         8
         3         6         9

&gt; (dataframe-display (rowtable-&gt;dataframe &#39;((1 4 7) (2 5 8) (3 6 9)) #f))
        V0        V1        V2
         1         4         7
         2         5         8
         3         6         9

&gt; (rowtable-&gt;dataframe &#39;((&quot;a&quot; &quot;b&quot; &quot;c&quot;) (1 4 7) (2 5 8) (3 6 9)) #t)
Exception in (make-dataframe alist): names are not symbols</code></pre>
</div>
<div id="read-and-write" class="section level3">
<h3>Read and write</h3>
<p>If you are working exclusively with dataframes, you can read and write them directly (i.e., without transposing to and from rowtables) with <code>dataframe-read</code> and <code>dataframe-write</code>. These procedures are straightforward because they are simply reading and writing the alists with <code>read</code> and <code>write</code>.</p>
<pre><code>(define (dataframe-write df path overwrite?)
  (when (and (file-exists? path) (not overwrite?))
    (assertion-violation path &quot;file already exists&quot;))
  (delete-file path)
  (with-output-to-file path
    (lambda () (write (dataframe-alist df)))))

(define (dataframe-read path)
  (make-dataframe (with-input-from-file path read)))</code></pre>
</div>
<div id="extract-values" class="section level3">
<h3>Extract values</h3>
<p><code>dataframe-values</code> returns all the values in a column as a simple list. Following R, I’ve included <code>$</code> as an alias for <code>dataframe-values</code>. This procedure is particularly useful when modifying and aggregating dataframes (as I will show in a future blog post). <code>dataframe-values-unique</code> returns the unique values from a column.</p>
<pre><code>&gt; (define df (make-dataframe &#39;((a 100 200 300) (b 4 5 6) (c 700 800 900))))

&gt; (dataframe-values df &#39;b)
(4 5 6)

&gt; ($ df &#39;b)                 
(4 5 6)

&gt; (map (lambda (name) ($ df name)) &#39;(c a))
((700 800 900) (100 200 300))

&gt; (define df1 (make-dataframe &#39;((x a a b) (y c d e))))

&gt; (dataframe-values-unique df1 &#39;x)
(a b)

&gt; (dataframe-values-unique df1 &#39;y)
(c d e)</code></pre>
<p><code>dataframe-ref</code> returns a dataframe based on a list of row indices and, optionally, the selected column names. I did not follow the principle of least surprise here because <code>dataframe-ref</code> takes a list of indices rather than a single value as in <code>list-ref</code>. For dataframes, the scenario of referencing a single row seemed less likely than a range of rows and I wanted to provide the option to simultaneously select the columns returned.</p>
<pre><code>&gt; (define df (make-dataframe &#39;((grp &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot;)
                               (trt &quot;a&quot; &quot;b&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot;)
                               (adult 1 2 3 4 5)
                               (juv 10 20 30 40 50))))

&gt; (dataframe-display (dataframe-ref df &#39;(0 2 4)))
       grp       trt     adult       juv
         a         a         1        10
         b         a         3        30
         b         b         5        50

&gt; (dataframe-display (dataframe-ref df &#39;(0 2 4) &#39;adult &#39;juv))
     adult       juv
         1        10
         3        30
         5        50</code></pre>
<p>In the <a href="/posts/select-drop-rename-dataframe-columns-chez-scheme/">next post</a>, I will show how to select, drop, and rename columns.</p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I was trying to think in terms of the <a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">principle of least surprise</a>, but the degree of surprise depends on the potential users. Am I targeting R or Scheme programmers? The most realistic scenario is that future me is the only potential user and I want that guy to think in terms of typical Scheme patterns.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
