---
title: Adding string matching to chez-docs
author: Travis Hinkelman
date: '2020-01-05'
slug: adding-string-matching-to-chez-docs
categories: ["chez-docs", "Chez Scheme"]
tags:
  - Levenshtein-distance
  - strings
  - do-loop
draft: false
---



<p>I recently wrote a little library, <a href="https://github.com/hinkelman/chez-docs"><code>chez-docs</code></a>, to make accessing documentation easier while learning Chez Scheme (<a href="/post/access-chez-scheme-documentation-from-repl/">blog post</a>). The main procedure, <code>doc</code>, in <code>chez-docs</code> only returns results for exact matches with <code>proc</code>.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> To aid in discovery, I’ve added a procedure, <code>find-proc</code>, that provides exact and approximate matching of search strings.</p>
<div id="levenshtein-distance" class="section level3">
<h3>Levenshtein Distance</h3>
<p>My initial thought was that I should approach this problem with approximate string matching. After a little searching, I learned that <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a> was one of the simplest approaches to calculate the distance between two strings. This excellent <a href="https://blogs.mathworks.com/cleve/2017/08/14/levenshtein-edit-distance-between-strings/">blog post</a> included a few MATLAB implementations of Levenshtein distance algorithms<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> that were relatively easy for me to follow because of my experience with MATLAB and R.</p>
<p>I first implemented the recursive algorithm<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> thinking that it would be most natural in Scheme, but it was unacceptably slow. I then implemented the iterative two-row algorithm and found the performance to be sufficiently snappy for my needs.</p>
<pre><code>(define (lev s t)
  (let* ([s (list-&gt;vector (string-&gt;list s))]
         [t (list-&gt;vector (string-&gt;list t))]
         [m (vector-length s)]
         [n (vector-length t)]
         [x (list-&gt;vector (iota (add1 n)))]
         [y (list-&gt;vector (make-list (add1 n) 0))])
    (do ((i 0 (add1 i)))
        ((= i m))
      (vector-set! y 0 i)
      (do ((j 0 (add1 j)))
          ((= j n))
        (let ([c (if (char=? (vector-ref s i) (vector-ref t j)) 0 1)])
          (vector-set! y (add1 j) (min (add1 (vector-ref y j))
                                       (add1 (vector-ref x (add1 j)))
                                       (+ c  (vector-ref x j))))))
      ;; swap x and y
      (let ([tmp x])
        (set! x y)
        (set! y tmp)))
    (vector-ref x n)))</code></pre>
<p>This is the first time that I’ve used <code>do</code> loops in Scheme. In the example below, the looping index <code>i</code> is initialized to zero and incremented by one on each pass through the loop. The loop is exited when <code>(= i 10)</code>. The (sort of) equivalent syntax in R is <code>for (i in 0:9) print(i)</code>.</p>
<pre><code>&gt; (do ((i 0 (add1 i)))
      ((= i 10))
    (display (string-append (number-&gt;string i) &quot; &quot;)))
0 1 2 3 4 5 6 7 8 9</code></pre>
<p><code>lev</code> tallies the numbers of insertions, deletions, and substitutions; a value of zero indicates an exact match.</p>
<pre><code>&gt; (map (lambda (x) (lev &quot;head&quot; x)) &#39;(&quot;head&quot; &quot;read&quot; &quot;load&quot; &quot;list-head&quot;))
(0 1 2 5)</code></pre>
</div>
<div id="exact-substring-matching" class="section level3">
<h3>Exact Substring Matching</h3>
<p><code>doc</code> uses <a href="https://scheme.com/tspl4/objects.html#./objects:s58"><code>assoc</code></a> to find any exact matches of the full string in the list of procedures. After working with the Levenshtein distance, I realized that exact matching of substrings would generally be more useful than fuzzy matching. I wrote the <code>string-match</code> procedure to test if a search string is present in the target string.</p>
<pre><code>(define (string-match s t)
  (let* ([s-list (string-&gt;list s)]
         [t-list (string-&gt;list t)])
    (if (char=? (car s-list) #\^)
        (string-match-helper (cdr s-list) t-list)
        (not (for-all (lambda (x) (equal? x #f))
                      (map (lambda (t-sub) (string-match-helper s-list t-sub))
                           (potential-matches (car s-list) t-list)))))))

;; loop through characters in search string
;; to check if search string is found in target string
(define (string-match-helper s-list t-list)
  (cond [(not t-list) #f] 
        [(null? s-list) #t]
        [(&lt; (length t-list) (length s-list)) #f]
        [(char=? (car s-list) (car t-list))
         (string-match-helper (cdr s-list) (cdr t-list))]
        [else #f]))

;; loop through target string
;; to find all potential substring matches
(define (potential-matches char t-list)
  (define (loop t-list results)
    (cond [(null? t-list)
           (remove-duplicates (reverse results))]
          [else
           (loop (cdr t-list) (cons (member char t-list) results))]))
  (loop t-list &#39;()))
  
(define (remove-duplicates ls)
  (cond [(null? ls)
         &#39;()]
        [(member (car ls) (cdr ls))
         (remove-duplicates (cdr ls))]
        [else
         (cons (car ls) (remove-duplicates (cdr ls)))]))</code></pre>
<p><code>member</code> is the workhorse of <code>string-match</code> (via <code>potential-matches</code>). It’s an interesting turn for me because when I first started using <code>member</code> in my Scheme code I was puzzled by why it didn’t work like <code>%in%</code> in R. For example, <code>(member 2 '(1 2 3))</code> returns <code>(2 3)</code>, but <code>2 %in% c(1, 2, 3)</code> returns <code>TRUE</code>. Because all values other than <code>#f</code> count as <code>#t</code> in Scheme, <code>member</code> can be used as a predicate, e.g., <code>(if (member 2 '(1 2 3)) 1 0)</code> returns <code>1</code>. Nonetheless, it wasn’t obvious to me how <code>member</code>’s behavior was useful…until I started writing <code>string-match</code>. Those experiences make programming fun.</p>
<p><code>string-match</code> returns a boolean value.</p>
<pre><code>&gt; (map (lambda (x) (string-match &quot;head&quot; x)) &#39;(&quot;head&quot; &quot;read&quot; &quot;load&quot; &quot;list-head&quot;))
(#t #f #f #t)</code></pre>
</div>
<div id="procedure-discovery" class="section level3">
<h3>Procedure Discovery</h3>
<p><code>find-proc</code> takes a <code>search-string</code> and two optional arguments, <code>max-results</code> and <code>fuzzy?</code>, which default to <code>10</code> and <code>#f</code>, respectively.</p>
<pre><code>(define find-proc
  (case-lambda
    [(search-string) (find-proc-helper search-string 10 #f)]
    [(search-string max-results) (find-proc-helper search-string max-results #f)]
    [(search-string max-results fuzzy?) (find-proc-helper search-string max-results fuzzy?)]))</code></pre>
<p><code>find-proc-helper</code> maps either <code>lev</code> or <code>string-match</code> to the full list of procedures, <code>proc-list</code>, and then sorts or filters the results, respectively.</p>
<pre><code>(define (find-proc-helper search-string max-results fuzzy?)
  (unless (string? search-string)
    (assertion-violation &quot;(find-proc search-string)&quot; &quot;search-string is not a string&quot;))
  (cond [fuzzy?
         (let* ([dist-list (map (lambda (x) (lev search-string x)) proc-list)]
                [dist-proc (map (lambda (dist proc) (cons dist proc)) dist-list proc-list)]
                [dist-proc-sort (sort (lambda (x y) (&lt; (car x) (car y))) dist-proc)])
           (prepare-results dist-proc-sort max-results))]
        [else
         (let* ([bool-list (map (lambda (x) (string-match search-string x)) proc-list)]
                [bool-proc (map (lambda (bool proc) (cons bool proc)) bool-list proc-list)]
                [bool-proc-filter (filter (lambda (x) (car x)) bool-proc)])
           (prepare-results bool-proc-filter max-results))]))

(define (prepare-results ls max-results)
  (let* ([len (length ls)]
         [max-n (if (&gt; max-results len) len max-results)])
    (map cdr (list-head ls max-n))))</code></pre>
<p>I first realized that Levenshtein distance might not be very useful for <code>find-proc</code> when searching for <code>head</code>, a commonly used procedure in R.</p>
<pre><code>&gt; (find-proc &quot;head&quot; 5 #t)
(&quot;read&quot; &quot;and&quot; &quot;cadr&quot; &quot;car&quot; &quot;cd&quot;)</code></pre>
<p>However, substring matching points us to the relevant function, <code>list-head</code>, in Chez Scheme.</p>
<pre><code>&gt; (find-proc &quot;head&quot; 5)
(&quot;list-head&quot; &quot;lookahead-char&quot; &quot;lookahead-u8&quot; &quot;make-boot-header&quot;)</code></pre>
<p>Fuzzy matching is useful, though, for discovery when there are options with similar forms, e.g., <code>hash-table?</code> and <code>hashtable?</code>.</p>
<pre><code>&gt; (find-proc &quot;hash-table?&quot; 3)
(&quot;hash-table?&quot;)
&gt; (find-proc &quot;hash-table?&quot; 3 #t)
(&quot;hash-table?&quot; &quot;hashtable?&quot; &quot;eq-hashtable?&quot;)</code></pre>
<p>The <code>^</code> indicates that only search strings found at the start of the procedure should be returned.</p>
<pre><code>&gt; (find-proc &quot;map&quot;)
(&quot;andmap&quot; &quot;hash-table-map&quot; &quot;map&quot; &quot;ormap&quot; &quot;vector-map&quot;)
&gt; (find-proc &quot;^map&quot;)
(&quot;map&quot;)

&gt; (find-proc &quot;file&quot; 3)
(&quot;&amp;i/o-file-already-exists&quot; &quot;&amp;i/o-file-does-not-exist&quot; &quot;&amp;i/o-file-is-read-only&quot;)
&gt; (find-proc &quot;^file&quot; 3)
(&quot;file-access-time&quot; &quot;file-buffer-size&quot; &quot;file-change-time&quot;)

&gt; (find-proc &quot;let&quot; 5)
(&quot;delete-directory&quot; &quot;delete-file&quot; &quot;eq-hashtable-delete!&quot; &quot;fluid-let&quot; &quot;fluid-let-syntax&quot;)
&gt; (find-proc &quot;^let&quot;)
(&quot;let*&quot; &quot;let*-values&quot; &quot;let-syntax&quot; &quot;let-values&quot; &quot;letrec&quot; &quot;letrec*&quot; &quot;letrec-syntax&quot;)</code></pre>
<p>Under fuzzy matching, the <code>^</code> is included as part of the Levenshtein distance calculation and, thus, should not be included in search strings when using fuzzy matching.</p>
<pre><code>&gt; (find-proc &quot;map&quot; 5 #t)
(&quot;map&quot; &quot;max&quot; &quot;*&quot; &quot;+&quot; &quot;-&quot;)
&gt; (find-proc &quot;^map&quot; 5 #t)
(&quot;map&quot; &quot;max&quot; &quot;car&quot; &quot;exp&quot; &quot;memp&quot;)</code></pre>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><code>proc</code> is shorthand for procedure, but not all of the items in <code>chez-docs</code> are procedures, e.g., <code>&amp;assertion</code>.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>The MATLAB post linked to implementations of Levenshtein distance in other languages, including <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#Scheme">Scheme</a>, but the Scheme example was hard for me to follow so I set it aside.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>After translating the MATLAB version of the recursive algorithm to Chez Scheme, I realized that a recursive example was available on <a href="http://rosettacode.org/wiki/Levenshtein_distance#Scheme">Rosetta Code</a>.<a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</div>
