---
title: Viewing source code in R and Chez Scheme
author: Travis Hinkelman
date: '2020-04-22'
slug: viewing-source-code-r-chez-scheme
categories: ["Chez Scheme", "R"]
tags:
  - methods
  - getAnywhere
  - inspect
  - introspection
  - read
  - filter
draft: no
---



<p>One of the advantages of open source software is being able to view, review, and learn from source code. Both R and Chez Scheme provide tools for accessing source code.</p>
<div id="r" class="section level3">
<h3>R</h3>
<p><a href="https://github.com/fishsciences/cfs.misc"><code>cfs.misc</code></a> is a small package with a few utility functions that are useful to our work at <a href="https://www.fishsciences.net">Cramer Fish Sciences</a>. One of the functions in <code>cfs.misc</code>, <code>water_year</code>, when given a date, returns the <a href="https://en.wikipedia.org/wiki/Water_year">water year</a> (as defined by the USGS). After installing <code>cfs.misc</code>, you can view the source code by simply typing the function name in the console<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> (here prefixed by the package name instead of loading the package via <code>library</code>).</p>
<pre><code>&gt; cfs.misc::water_year 
function (x) 
{
    x_lt &lt;- as.POSIXlt(x)
    x_lt$year + 1900L + ifelse(x_lt$mon + 1L &gt;= 10L, 1L, 0L)
}
&lt;bytecode: 0x7f9e33e3f980&gt;
&lt;environment: namespace:cfs.misc&gt;</code></pre>
<p><code>cfs.misc::water_year</code> is based on <code>lubridate::year</code>. Let’s look at the source code for <code>lubridate::year</code>.</p>
<pre><code>&gt; lubridate::year
function (x) 
UseMethod(&quot;year&quot;)
&lt;bytecode: 0x7f9e316ee8d0&gt;
&lt;environment: namespace:lubridate&gt;</code></pre>
<p>Encountering <code>UseMethod(&quot;year&quot;)</code> tells us that <code>lubridate::year</code> is a generic function and the method used depends on the object passed to the generic function. Let’s see what methods are available.</p>
<pre><code>&gt; methods(lubridate::year)
[1] year.default* year.Period* 
see &#39;?methods&#39; for accessing help and source code</code></pre>
<p><code>year.default</code> looks promising.</p>
<pre><code>&gt; lubridate::year.default
Error: &#39;year.default&#39; is not an exported object from &#39;namespace:lubridate&#39;</code></pre>
<p>That makes sense. You won’t find <code>year.default</code> on the <a href="https://lubridate.tidyverse.org/reference/index.html"><code>lubridate</code> reference page</a>. The triple-colon operator, <code>:::</code>, allows us to use unexported functions.</p>
<pre><code>&gt; lubridate:::year.default(&quot;2020-04-22&quot;)
[1] 2020</code></pre>
<p>We can also use <code>:::</code> to view source code for unexported functions.</p>
<pre><code>&gt; lubridate:::year.default
function (x) 
as.POSIXlt(x, tz = tz(x))$year + 1900
&lt;bytecode: 0x7f9e37ecd9f0&gt;
&lt;environment: namespace:lubridate&gt;</code></pre>
<p>Alternatively, you could use <code>getAnywhere</code>.</p>
<pre><code>&gt; getAnywhere(&quot;year.default&quot;)
A single object matching ‘year.default’ was found
It was found in the following places
  namespace:lubridate
with value

function (x) 
as.POSIXlt(x, tz = tz(x))$year + 1900
&lt;bytecode: 0x7f9e37ecd9f0&gt;
&lt;environment: namespace:lubridate&gt;</code></pre>
<p>Next, let’s look at <code>dplyr::select</code> as a more complex example.</p>
<pre><code>&gt; methods(dplyr::select)
[1] select.data.frame* select.default*    select.grouped_df* select.list        select.tbl_cube*  
see &#39;?methods&#39; for accessing help and source code

&gt; dplyr:::select.data.frame
function (.data, ...) 
{
    vars &lt;- tidyselect::vars_select(tbl_vars(.data), !!!enquos(...))
    select_impl(.data, vars)
}
&lt;bytecode: 0x7f9e32a9aa68&gt;
&lt;environment: namespace:dplyr&gt;

&gt; dplyr:::select_impl
function (df, vars) 
{
    .Call(`_dplyr_select_impl`, df, vars)
}
&lt;bytecode: 0x7f9e39c12360&gt;
&lt;environment: namespace:dplyr&gt;</code></pre>
<p>As we drill down into the source code, we eventually hit <code>.Call</code>, which indicates that compiled code from another language is being called. We can go no farther from R and would need to seek out the source file for the compiled code.</p>
<p>In contrast, <code>poorman::select</code><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> provides similar functionality as <code>dplyr::select</code>, but the source code is written in base R and, thus, is more easily accessible.</p>
<pre><code>&gt; poorman::select
function (.data, ...) 
{
    map &lt;- names(deparse_dots(...))
    col_pos &lt;- select_positions(.data, ..., group_pos = TRUE)
    res &lt;- extract(.data, , col_pos, drop = FALSE)
    to_map &lt;- nchar(map) &gt; 0L
    colnames(res)[to_map] &lt;- map[to_map]
    if (has_groups(.data)) 
        res &lt;- set_groups(res, group_vars(.data))
    res
}
&lt;bytecode: 0x7f9e35bd14d0&gt;
&lt;environment: namespace:poorman&gt;</code></pre>
<p>I’ve only shown examples from R packages, but the same techniques also work with base R code. Everything that I’ve covered so far is better explained in <em>R Help Desk: Accessing the Sources</em> by Uwe Ligges in <a href="https://cran.r-project.org/doc/Rnews/Rnews_2006-4.pdf">this issue</a> of <em>R News</em>.</p>
</div>
<div id="chez-scheme" class="section level3">
<h3>Chez Scheme</h3>
<p>In Chez Scheme, we can view source code for exported procedures with the <a href="https://cisco.github.io/ChezScheme/csug9.5/debug.html#./debug:s22">inspector</a>. Let’s load up my <a href="https://hinkelman.github.io/chez-stats/"><code>chez-stats</code> library</a> and inspect <code>mean</code>.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
<pre><code>&gt; (import (chez-stats statistics))

&gt; (inspect mean)
#&lt;procedure mean at statistics.ss:3309&gt;                           : c
(lambda (ls) ((...) ls ...) (/ (...) ...))                        : p

(lambda (ls)
  (($top-level-value
     &#39;#{check-list iyij3kx7j76i8m1qgvaikyqyy-2})
    ls
    &quot;ls&quot;
    &quot;(mean ls)&quot;)
  (/ (apply + ls) (length ls)))

(lambda (ls) ((...) ls ...) (/ (...) ...))                        : q</code></pre>
<p>The inspector is an interactive tool. To see the available commands, type <code>?</code> after the <code>:</code> prompt. Type <code>q</code> to quit the inspector. In the example above, I first ask for the code with <code>c</code> and then type <code>p</code> for pretty printing of the code.</p>
<p><code>mean</code> calls <code>check-list</code> to check if the input <code>ls</code> is a list. <code>check-list</code> is not exported from <code>chez-stats</code> and is not availble to the inspector.</p>
<pre><code>&gt; (inspect check-list)
Exception: variable check-list is not bound</code></pre>
<p>However, because I’ve set up assertion procedures, like <code>check-list</code>, as part of a library, we can still view <code>check-list</code> with the inspector.</p>
<pre><code>&gt; (import (chez-stats assertions))

&gt; (inspect check-list)
#&lt;procedure check-list at assertions.ss:227&gt;                      : c
(lambda (ls ls-name who) (if (...) ...) (if (...) ...) ...)       : p

(lambda (ls ls-name who)
  (if (not (list? ls))
      (assertion-violation who
        (string-append ls-name &quot; is not a list&quot;))
      (#2%void))
  (if (not (for-all real? ls))
      (assertion-violation who
        (string-append
          &quot;at least one element of &quot;
          ls-name
          &quot; is not a real number&quot;))
      (#2%void))
  (if (null? ls)
      (assertion-violation who
        (string-append ls-name &quot; is empty&quot;))
      (#2%void)))</code></pre>
<p>The code returned by the inspector is expanded. All of the <code>if</code> statements in <code>check-list</code> were written as <code>unless</code> or <code>when</code>, but expanded to <code>if</code> with a dead branch when shown by the inspector. I can see how this could be useful for better understanding how Chez works, but, generally, if I’m digging around in source code, I would prefer to see the more human-readable version.</p>
<p>I only recently learned about the inspector from the Chez Scheme <a href="https://groups.google.com/forum/#!topic/chez-scheme/x6auPRuweEs">mailing list</a>. I’m happy to have it in my toolbelt, but a little disappointed that it only works for procedures exported from external libraries, not for unexported procedures or Chez’s built-in procedures. In the case of my <a href="https://hinkelman.github.io/dataframe/"><code>dataframe</code> library</a>, for example, most of the exported procedures are simple wrappers around layers of unexported procedures, which limits the utility of the inspector.</p>
<p>It eventually occurred to me, though, that Chez maybe doesn’t need to provide a lot of built-in tools for inspecting code because, with s-expressions, it is very easy to inspect the code yourself. For example, if you have downloaded my <code>dataframe</code> library, then we can read the source code as a list.</p>
<pre><code>(define df-code (with-input-from-file &quot;/path/to/df.ss&quot; read))</code></pre>
<p>Next, we write procedures to filter <code>df-code</code> for elements that start with <code>define</code> and search for a specified procedure within that list of <code>define</code> elements.</p>
<pre><code>(define (get-define ls)
  (filter (lambda (x) (and (pair? x) (symbol=? (car x) &#39;define))) ls))
  
(define (find-proc ls proc-symbol)
  (filter (lambda (x) (and (pair? (cadr x)) (symbol=? (caadr x) proc-symbol))) ls))</code></pre>
<p>We can use these very simple procedures to quickly view the source code for an unexported procedure, <code>alist-select</code>.</p>
<pre><code>&gt; (define df-define (get-define df-code))

&gt; (car df-define)
(define (thread-last-helper f value . body)
  (apply f (append body (list value))))

&gt; (find-proc df-define &#39;alist-select)
((define (alist-select alist names)
   (map (lambda (name) (assoc name alist)) names)))</code></pre>
<p>Finally, just to drive home the point that we needed to read the file ourselves…</p>
<pre><code>&gt; (import (dataframe df))

&gt; (inspect alist-select)
Exception: variable alist-select is not bound</code></pre>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>If you are using RStudio, you can also view source code with <code>View(cfs.misc::water_year)</code>, which opens a tab to show the source code and omits the bytecode information.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>The <a href="https://github.com/nathaneastwood/poorman"><code>poorman</code> package</a> attempts to replicate <code>dplyr</code> functionality using only base R code. This is not an endorsement of <code>poorman</code>. I have never used it myself, but I think it provides an interesting contrast to <code>dplyr</code>.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>When I tried to use the inspector from the Emacs REPL, it would occassionally hang up. Not sure if that is a quirk of my system or session, but I now run <code>inspect</code> after launching Chez from the terminal.<a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</div>
